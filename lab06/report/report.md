---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Управление процессами"
author: "Ришард Когенгар"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true
toc-depth: 2
lof: true
lot: true
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float}
  - \floatplacement{figure}{H}
---

# Цель работы

Получить навыки управления процессами операционной системы.

# Ход выполнения

## Управление заданиями

1. Для выполнения операций с заданиями получены полномочия администратора с помощью команды **su**.  
   После входа в root-оболочку были запущены следующие команды:
   - `sleep 3600 &` — запуск таймера на 3600 секунд в фоновом режиме;
   - `dd if=/dev/zero of=/dev/null &` — запуск процесса генерации нагрузки в фоне;
   - `sleep 7200` — запуск таймера на 7200 секунд на переднем плане.

2. Поскольку команда `sleep 7200` была запущена без символа `&`, управление оболочкой было заблокировано данным процессом.  
   Для остановки его выполнения использовано сочетание клавиш **Ctrl + Z**, в результате чего задание было переведено в состояние **Stopped**.

3. Для просмотра списка активных заданий текущей оболочки выполнена команда **jobs**.  
   В выводе отображены три задания:
   - задание №1 — **Running** (sleep 3600);
   - задание №2 — **Running** (dd if=/dev/zero of=/dev/null);
   - задание №3 — **Stopped** (sleep 7200).

   ![Просмотр списка заданий jobs](Screenshot_1.png)

4. Для продолжения выполнения задания №3 в фоновом режиме использована команда **bg 3**.  
   После этого повторный вывод команды **jobs** показал, что задание №3 перешло в состояние **Running**.

5. Для переноса задания №1 на передний план выполнена команда **fg 1**.  
   После возврата управления процесс был остановлен пользователем с помощью **Ctrl + C**.

6. Аналогичным образом были остановлены задания №2 и №3: каждое из них переводилось на передний план командой **fg**, после чего завершалось сочетанием **Ctrl + C**.  
   Повторный вывод команды **jobs** подтвердил отсутствие активных заданий.

   ![Завершение всех заданий и пустой вывод jobs](Screenshot_2.png)

7. Во втором терминале под учётной записью пользователя был запущен процесс `dd if=/dev/zero of=/dev/null &`.  
   После этого второй терминал был закрыт командой **exit**.

8. В первом терминале под учётной записью пользователя была запущена утилита мониторинга процессов **top**.  
   В списке процессов был обнаружен процесс `dd`, продолжающий выполнение несмотря на закрытие терминала, из которого он был запущен.

   ![Отображение процесса dd в top](Screenshot_3.png)

9. После повторного запуска **top** процесс `dd` был завершён с помощью команды **k** (kill) с указанием его PID.  
   После выхода из **top** подтверждено, что процесс `dd` больше не выполняется.

   ![Отсутствие процесса dd после завершения](Screenshot_4.png)

## Управление процессами

1. Получены полномочия администратора и в одной root-оболочке последовательно запущены три процесса `dd if=/dev/zero of=/dev/null` в фоновом режиме.

2. Для отображения всех процессов, содержащих строку `dd`, выполнена команда **ps aux | grep dd**.  
   В выводе отображены запущенные процессы `dd` с их идентификаторами PID.

   ![Просмотр процессов dd через ps aux](Screenshot_5.png)

3. Для изменения приоритета одного из процессов `dd` использована команда **renice** с указанием PID выбранного процесса.  
   В результате приоритет процесса был изменён с значения 0 на значение 5, что подтверждено выводом команды.

4. Для просмотра иерархии процессов выполнена команда **ps fax | grep -B5 dd**.  
   Это позволило отобразить дерево процессов и определить PID родительской root-оболочки, из которой были запущены все процессы `dd`.

5. Для завершения всех процессов `dd` одновременно выполнено принудительное завершение родительской оболочки с помощью сигнала **SIGKILL**.  
   После выполнения команды оболочка была закрыта, а все дочерние процессы `dd` автоматически остановлены, что подтверждает зависимость дочерних процессов от родительского.

   ![Завершение родительского процесса и остановка dd](Screenshot_6.png)

## Самостоятельная работа  

### Задание 1

1. В root-оболочке трижды запущена команда **dd if=/dev/zero of=/dev/null** в фоновом режиме.  
   В результате были созданы три параллельно выполняющихся процесса, каждому из которых был присвоен собственный идентификатор PID.

   ![Запуск трёх процессов dd в фоновом режиме](Screenshot_7.png)

2. Для одного из запущенных процессов `dd` был изменён приоритет с использованием утилиты **renice** и значения приоритета **−5**.  
   Команда выполнилась успешно, что подтверждается сообщением об изменении приоритета с исходного значения на новое.

3. Для того же процесса приоритет был изменён повторно, на этот раз с использованием значения **−15**.  
   В результате процесс получил более высокий приоритет по сравнению с предыдущим состоянием.  
   Разница между значениями −5 и −15 заключается в том, что чем меньше числовое значение приоритета (ближе к −20), тем больше процессорного времени ядро выделяет данному процессу.

4. Для завершения всех ранее запущенных процессов `dd` использована команда **killall dd**.  
   В результате выполнения команды все процессы были успешно завершены, что подтверждается сообщениями о завершении заданий.

### Задание 2

1. Программа **yes** была запущена в фоновом режиме с подавлением потока вывода путём перенаправления вывода в `/dev/null`.  
   Процесс начал выполняться в фоне, о чём свидетельствует его статус **Running**.

   ![Запуск yes в фоне с подавлением вывода](Screenshot_8.png)

2. Далее программа **yes** была запущена на переднем плане с подавлением потока вывода.  
   Выполнение программы было приостановлено с помощью сочетания клавиш **Ctrl + Z**, после чего она была повторно запущена с теми же параметрами и завершена пользователем.

3. После этого программа **yes** была запущена на переднем плане без подавления потока вывода.  
   Процесс был приостановлен, затем повторно запущен с теми же параметрами и завершён пользователем.

   ![Запуск yes без подавления вывода](Screenshot_9.png)

4. Состояния всех заданий были проверены с помощью команды **jobs**.  
   В выводе отображались задания в состояниях **Running** и **Stopped**, в зависимости от предыдущих действий.

5. Процесс, выполнявшийся в фоновом режиме, был переведён на передний план и затем остановлен пользователем с помощью **Ctrl + C**.

   ![Перевод фонового процесса на передний план и остановка](Screenshot_10.png)

6. Один из процессов `yes` с подавлением потока вывода был переведён в фоновый режим.  
   После этого его состояние изменилось на **Running**, что было подтверждено повторным вызовом команды **jobs**.

7. Процесс `yes` был запущен в фоновом режиме с использованием механизма, позволяющего ему продолжать выполнение после отключения от терминала.  
   В списке заданий данный процесс отображался как выполняющийся независимо от текущей сессии.

8. Окно терминала было закрыто, после чего консоль была запущена повторно.  
   Проверка показала, что процесс `yes` продолжил свою работу, что подтверждает корректность его запуска.

9. Для получения информации о текущих процессах в системе использована утилита **top**.  
   В списке процессов были обнаружены активные процессы `yes`, потребляющие значительную долю процессорного времени.

   ![Отображение процессов yes в утилите top](Screenshot_11.png)

10. Дополнительно были запущены ещё три процесса **yes** в фоновом режиме с подавлением потока вывода.

    ![Запуск дополнительных процессов yes](Screenshot_12.png)

11. Два процесса были завершены:  
    - один — с использованием его PID;  
    - второй — с использованием идентификатора задания.  
    В обоих случаях процессы были успешно остановлены.

12. Была выполнена попытка отправки сигнала **SIGHUP (1)** процессу, запущенному с использованием механизма сохранения выполнения после выхода из терминала, и обычному процессу.  
    В результате обычный процесс был завершён, тогда как процесс, запущенный с сохранением выполнения, продолжил работу.

13. После этого были запущены ещё несколько процессов **yes** в фоновом режиме с подавлением потока вывода.  
    Все они были одновременно завершены с помощью команды **killall**, что позволило остановить группу однотипных процессов одной командой.

14. В завершение одна программа **yes** была запущена в фоновом режиме с подавлением вывода, а вторая — с теми же параметрами, но с увеличенным приоритетом с использованием утилиты **nice**.  
    Сравнение абсолютных и относительных приоритетов показало, что процесс с изменённым приоритетом получает меньше процессорного времени.

15. С помощью утилиты **renice** был изменён приоритет одного из запущенных процессов `yes`.  
    Повторная проверка приоритетов подтвердила корректность внесённых изменений и их влияние на планирование процессов.

## Вывод

В ходе работы были изучены и отработаны основные механизмы управления заданиями и процессами в ОС Linux. Освоены приёмы запуска процессов в фоновом и переднем режимах, их приостановки, возобновления и завершения с использованием команд управления заданиями. Практически продемонстрировано изменение приоритетов процессов с помощью `nice` и `renice` и влияние этих изменений на распределение процессорного времени. Рассмотрены способы завершения отдельных процессов и групп процессов, а также поведение процессов при получении различных сигналов и при завершении родительской оболочки. Полученные результаты подтверждают корректную работу средств управления процессами и заданий в Linux.

# Контрольные вопросы

**1. Какая команда даёт обзор всех текущих заданий оболочки?**  
Команда `jobs` — отображает список всех заданий, запущенных в текущей оболочке, с указанием их номеров и состояний (Running, Stopped).

**2. Как остановить текущее задание оболочки, чтобы продолжить его выполнение в фоновом режиме?**  
Необходимо приостановить выполнение текущего задания сочетанием клавиш `Ctrl + Z`, после чего выполнить команду `bg`, указав номер задания при необходимости.

**3. Какую комбинацию клавиш можно использовать для отмены текущего задания оболочки?**  
Для отмены текущего задания используется сочетание клавиш `Ctrl + C`, которое отправляет процессу сигнал завершения.

**4. Необходимо отменить одно из начатых заданий. Доступ к оболочке, в которой в данный момент работает пользователь, невозможен. Что можно сделать, чтобы отменить задание?**  
Можно определить идентификатор процесса (PID) с помощью команд `ps` или `top`, после чего завершить процесс командой `kill` или `kill -9`, используя найденный PID.

**5. Какая команда используется для отображения отношений между родительскими и дочерними процессами?**  
Для отображения иерархии процессов используется команда `ps fax`, которая показывает дерево процессов и их взаимосвязи.

**6. Какая команда позволит изменить приоритет процесса с идентификатором 1234 на более высокий?**  
Для повышения приоритета процесса используется команда  
`renice -n -5 1234`,  
где отрицательное значение означает более высокий приоритет.

**7. В системе в настоящее время запущено 20 процессов dd. Как проще всего остановить их все сразу?**  
Проще всего использовать команду `killall dd`, которая завершит все процессы с именем `dd`.

**8. Какая команда позволяет остановить команду с именем mycommand?**  
Для остановки процесса по имени используется команда `killall mycommand`.

**9. Какая команда используется в top, чтобы убить процесс?**  
В утилите `top` для завершения процесса используется команда `k` с последующим вводом PID процесса и сигнала.

**10. Как запустить команду с достаточно высоким приоритетом, не рискуя, что не хватит ресурсов для других процессов?**  
Для этого используется команда `nice` с умеренно повышенным приоритетом, например `nice -n -5`, что позволяет увеличить приоритет процесса, не нарушая баланс распределения ресурсов в системе.
