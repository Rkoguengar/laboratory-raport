---
## Front matter
title: "Отчёт по лабораторной работе №10"
subtitle: "Основы работы с модулями ядра операционной системы"
author: "Ришард Когенгар"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true
toc-depth: 2
lof: true
lot: true
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float}
  - \floatplacement{figure}{H}
---

# Цель работы

Получить навыки работы с утилитами управления модулями ядра операционной системы.

# Ход выполнения

## Управление модулями ядра из командной строки

1. В терминале получены полномочия администратора командой `su -`, что позволило выполнять операции загрузки/выгрузки модулей ядра и просмотр служебной информации без ограничений прав доступа.

2. Для определения устройств системы и связанных с ними драйверов/модулей выполнена команда `lspci -k`.  
   По выводу видно, какие PCI-устройства обнаружены и какой модуль ядра обслуживает каждое из них (строки **Kernel driver in use** и **Kernel modules**). В системе определены, в частности:  
   - IDE-контроллер Intel PIIX4, обслуживаемый драйвером **ata_piix** (модули `ata_piix`, `ata_generic`);  
   - видеоконтроллер SVGA, обслуживаемый драйвером **vmwgfx** (модуль `vmwgfx`);  
   - сетевой адаптер Intel PRO/1000 MT, обслуживаемый драйвером **e1000** (модуль `e1000`);  
   - сервисное устройство VirtualBox Guest Service, обслуживаемое драйвером **vboxguest** (модуль `vboxguest`);  
   - аудиоконтроллер AC’97, обслуживаемый драйвером **snd_intel8x0** (модуль `snd_intel8x0`);  
   - SATA-контроллер AHCI, обслуживаемый драйвером **ahci** (модуль `ahci`).  
   Таким образом, команда позволяет установить связь «устройство → активный драйвер/модуль ядра», что важно для диагностики и управления поддержкой оборудования.

   ![Просмотр устройств и связанных модулей командой lspci -k](Screenshot_1.png)

3. Для просмотра списка загруженных модулей ядра выполнена команда `lsmod | sort`.  
   В выводе отображаются: **имя модуля**, его **размер** и поле **Used by** (количество/перечень зависимостей, т.е. кто использует модуль).  
   В списке присутствуют как аппаратные драйверы (например, `e1000`, `vmwgfx`, `ahci`, `ata_piix`), так и системные модули (например, `dm_mod`, `fuse`, `crc32c*`, `i2c_piix4`), что подтверждает корректную загрузку основных подсистем.

   ![Просмотр загруженных модулей ядра](Screenshot_2.png)

## Загрузка и выгрузка модуля ext4

4. Проверено, загружен ли модуль файловой системы ext4, командой `lsmod | grep ext4`.  
   До загрузки модуль в списке отсутствовал (совпадений не найдено), что указывает на то, что поддержка ext4 не была активирована как модуль в текущей сессии.

5. Выполнена загрузка модуля `ext4` командой `modprobe ext4`.  
   Повторная проверка `lsmod | grep ext4` показала появление модуля **ext4**, а также связанных с ним модулей **jbd2** и **mbcache**, которые используются ext4 как зависимости (журналирование и кэширование метаданных).

6. Получена подробная информация о модуле ext4 командой `modinfo ext4`.  
   В выводе отражены ключевые характеристики:  
   - **filename** — путь к файлу модуля (`.../kernel/fs/ext4/ext4.ko.xz`);  
   - **license/description/author** — лицензия, описание и авторы;  
   - **alias** — альтернативные идентификаторы (в т.ч. совместимость с `ext2/ext3` через алиасы);  
   - **depends** — зависимости (`jbd2`, `mbcache`);  
   - **vermagic** — строка совместимости с версией/сборкой ядра;  
   - **sig_*** и **signature** — сведения о цифровой подписи модуля.  
   Отдельно отмечено, что у модуля **нет параметров** (в `modinfo` отсутствуют строки `parm:`), то есть при загрузке `modprobe ext4` нельзя настраивать его поведение через параметры модуля.

   ![Загрузка ext4 и просмотр информации о модуле](Screenshot_3.png)

7. Выполнена попытка выгрузки модуля ext4 командой `modprobe -r ext4`.  
   Команда была введена несколько раз; после этого проверка `lsmod | grep ext4` не вывела совпадений, что означает успешную выгрузку модуля (при отсутствии активных ext4-разделов/использований, удерживающих модуль в памяти).

8. Выполнена попытка выгрузки модуля `xfs` командой `modprobe -r xfs`.  
   Система вернула сообщение об ошибке: **`modprobe: FATAL: Module xfs is in use.`**, что означает невозможность выгрузки из-за активного использования (как правило, когда корневая/рабочая файловая система или смонтированные разделы используют XFS).

   ![Выгрузка ext4 и ошибка при выгрузке xfs](Screenshot_4.png)

## Загрузка модулей ядра с параметрами на примере bluetooth

9. Проверено наличие модуля Bluetooth командой `lsmod | grep bluetooth`.  
   До загрузки совпадений не было, что указывает на отсутствие загруженного модуля `bluetooth` в текущий момент.

10. Выполнена загрузка модуля командой `modprobe bluetooth`.  
    После этого команда `lsmod | grep bluetooth` показала появление модуля **bluetooth**, а также зависимого модуля **rfkill**, используемого подсистемой для программной блокировки/разблокировки радиоинтерфейсов.

11. Выполнена команда `modinfo bluetooth` для просмотра сведений о модуле.  
    В выводе отображены: путь к файлу модуля (`.../kernel/net/bluetooth/bluetooth.ko.xz`), описание и версия подсистемы, зависимость **depends: rfkill**, а также цифровая подпись и строка совместимости `vermagic`.

   ![Загрузка bluetooth и базовая информация о модуле](Screenshot_5.png)

12. В `modinfo bluetooth` дополнительно представлены параметры модуля (строки `parm:`), которые могут задаваться при загрузке:  
    - `disable_esco` — отключение создания eSCO-соединений (логический параметр `bool`);  
    - `disable_ertm` — отключение режима Enhanced Retransmission Mode (логический параметр `bool`);  
    - `enable_ecred` — включение режима Enhanced Credit Flow Control (логический параметр `bool`).  
    Данные параметры могут применяться при загрузке через `modprobe bluetooth <param>=0/1`, позволяя управлять отдельными возможностями стека Bluetooth.

13. Выполнена выгрузка модуля командой `modprobe -r bluetooth`.  
    Ошибок не возникло, что означает успешное удаление модуля из памяти при отсутствии активных зависимостей/использований.

   ![Параметры модуля bluetooth и выгрузка](Screenshot_6.png)

## Обновление ядра системы

14. Проверена текущая версия ядра командой `uname -r`.  
    Используется ядро **6.12.0-124.27.1.el10_1.x86_64**.

15. Выведен список пакетов, относящихся к ядру, командой `dnf list kernel`.  
    В системе установлены пакеты ядра, включая версию **6.12.0-124.27.1.el10_1**, а также присутствует более ранний пакет (из окружения установки), что типично для систем, где сохраняются несколько версий ядра.

16. Выполнено обновление метаданных и пакетов командой `dnf upgrade --refresh`, после чего выполнено обновление ядра `dnf update kernel`.  
    По выводу **Dependencies resolved / Nothing to do / Complete!** система актуальна, обновления для ядра на момент проверки отсутствуют.

   ![Проверка версии ядра и попытка обновления через dnf](Screenshot_7.png)

17. После перезагрузки выполнена повторная проверка версии ядра `uname -r` и вывод сведений о системе `hostnamectl`.  
    Версия ядра осталась **6.12.0-124.27.1.el10_1.x86_64**, что соответствует состоянию «обновлений нет».  
    Команда `hostnamectl` также подтверждает: ОС **Rocky Linux 10.1 (Red Quartz)**, виртуализация **oracle/VirtualBox**, архитектура **x86-64**, а статическое имя хоста — **rishardkogengar.localdomain**.

   ![Проверка версии ядра после перезагрузки и сведения о системе](Screenshot_8.png)


## Вывод

В ходе работы были изучены основные приёмы управления модулями ядра Linux из командной строки. Получены навыки определения аппаратных устройств и соответствующих им драйверов, просмотра загруженных модулей, а также их загрузки и выгрузки с учётом зависимостей. Установлено, что модули, активно используемые системой (например, `xfs`), не могут быть выгружены. Рассмотрена загрузка модулей с параметрами на примере подсистемы Bluetooth. Также выполнена проверка и обновление ядра операционной системы Rocky Linux, подтверждена актуальность установленной версии ядра и корректность работы системы после перезагрузки.

# Контрольные вопросы

**1. Какая команда показывает текущую версию ядра, которая используется на вашей системе?**  
Для просмотра текущей версии загруженного и используемого ядра применяется команда  
`uname -r`.  
Она выводит точную версию ядра Linux, с которым в данный момент работает операционная система.

**2. Как можно посмотреть более подробную информацию о текущей версии ядра операционной системы?**  
Более подробную информацию можно получить с помощью следующих команд:  
`uname -a` — выводит расширенные сведения, включая версию ядра, архитектуру и дату сборки.  
`hostnamectl` — отображает информацию об ОС, версии ядра, архитектуре и типе виртуализации.  
Дополнительно сведения о пакетах ядра можно посмотреть командой `dnf list kernel`.

**3. Какая команда показывает список загруженных модулей ядра?**  
Для просмотра всех загруженных в память модулей ядра используется команда  
`lsmod`.  
Она отображает имя модуля, его размер и список зависимостей (или количество использующих его модулей).

**4. Какая команда позволяет вам определять параметры модуля ядра?**  
Для определения параметров модуля ядра применяется команда  
`modinfo <имя_модуля>`.  
В выводе параметры отображаются строками `parm:` с указанием имени параметра и его назначения.

**5. Как выгрузить модуль ядра?**  
Выгрузка модуля ядра выполняется командой  
`modprobe -r <имя_модуля>`  
или альтернативно `rmmod <имя_модуля>`.  
При этом модуль будет выгружен только в том случае, если он не используется системой.

**6. Что вы можете сделать, если получите сообщение об ошибке при попытке выгрузить модуль ядра?**  
Если система сообщает, что модуль используется, необходимо:  
- определить, какие процессы или подсистемы используют данный модуль;  
- остановить службы или размонтировать файловые системы, связанные с модулем;  
- после этого повторить попытку выгрузки;  
- если модуль критически важен (например, файловая система корня), его выгрузка невозможна без перезагрузки системы.

**7. Как определить, какие параметры модуля ядра поддерживаются?**  
Поддерживаемые параметры модуля определяются командой  
`modinfo <имя_модуля>`.  
Все доступные параметры перечисляются в выводе в виде строк `parm:`, где указано имя параметра, его назначение и тип.

**8. Как установить новую версию ядра?**  
Установка или обновление ядра выполняется средствами пакетного менеджера:  
`dnf update kernel` — обновление пакета ядра до доступной версии;  
`dnf upgrade --refresh` — обновление системы с обновлением метаданных репозиториев.  
После установки нового ядра требуется перезагрузка системы и выбор нового ядра при старте ОС.
